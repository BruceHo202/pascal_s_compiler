program dyaares(input,output);
    const aa = 5; bb = 11; cc = 'a';
    type symbol = integer; symbol2 = real; 
    var m: symbol;
        r: record a:symbol2; b: array[aa..bb,1..aa] of record a:symbol2 end end;
        ch, ch2: char;
        int, int2: integer;
        bol, bol2: Boolean;
        rea, rea2: real;
        j: integer;
        
        test4: array['a'..'b'] of integer;
        test5: array['a'..'b', 1..2] of integer;
        
        n, i: integer;
        arr: array[0..15000] of integer;
        mid: integer;
        ans: real;
        
        xx, yy ,modnum:integer;
        
    procedure outaval;
        begin m := aa; write(m) end;
    procedure newaval;
        var m:integer;
            test:real;
        begin test := 6.6; m:= 5 and 5; write(m); outaval end;
    procedure addaval;
        begin m := m * 5 + bb; outaval end;
    function test1( h:integer; hh:char; hhh: Boolean):integer;
        function test2:integer;
            begin end;
        begin h := h + 1 end;
        
    procedure test3(var h:integer; var hh:char);
        begin h := 12345; hh := 'z' end;

    function partition(l: integer; r: integer):integer;
        var i, j, val, t: integer;
    begin
        i := l + 1;
        j := r;
        val := arr[l];
        writeln;
        repeat
            while ((arr[i] < val) and (i <= j)) do i := i + 1;
            while ((arr[j] > val) and (i <= j)) do j := j - 1;
            if not (i > j) then
            begin
                t := arr[i];
                arr[i] := arr[j];
                arr[j] := t;
                i := i + 1;
                j := j - 1
            end;
        until i > j;
        t := arr[l];
        arr[l] := arr[j];
        arr[j] := t;
        partition := j
    end;
    
    
    procedure quickasort(l: integer; r: integer);
        var pos: integer;
    begin
        if l < r then
        begin
            pos := partition(l, r);
            quickasort(l, pos - 1);
            quickasort(pos + 1, r)
        end
    end;
    
    function quickpow(p,q:integer):integer;
        var res:integer;
    begin
        res:=1;
        while q<>0 do
            begin
                if q mod 2 = 1 then res:=res*p;
                p:=p*p;
                p:=p mod modnum;
                res:=res mod modnum;
                q:=q div 2
            end;
        quickpow:=res
    end;
    

    begin 
        
        
        {writeln('quickpow,input:x、y、modnum');}
        read(xx);
        read(yy);
        read(modnum);
        {write('(x^y)%modnum = ');}
        writeln(quickpow(xx, yy));
        
        read(n);
        while n <> 0 do 
        begin
        
            for i := 1 to n do begin read(arr[i]) end;

            quickasort(1, n);

            for i := 1 to n do
                if i <= n then writeln(arr[i]);
            writeln;
            read(n)
        end
    end.
